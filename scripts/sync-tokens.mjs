import fs from 'fs';
import path from 'path';

const FIGMA_TOKENS_FILE = 'figma-design-token.json';
const OUTPUT_FILE = 'tailwind.tokens.js';

function rgbaToHex(r, g, b, a) {
  if (a !== 1) {
    return `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`;
  }
  const toHex = (c) => `0${Math.round(c * 255).toString(16)}`.slice(-2);
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

function processValue(value, allVarsMap) {
    if (!value) {
        return null;
    }

    if (value.type === 'VARIABLE_ALIAS') {
        const aliasData = allVarsMap.get(value.id);
        if (aliasData) {
            const { variable: aliasVar, modes: aliasModes } = aliasData;
            // Use the first mode of the aliased variable's collection
            const modeId = aliasModes[0].modeId;
            return processValue(aliasVar.valuesByMode[modeId], allVarsMap);
        }
        return null;
    }

    if (typeof value === 'object' && 'r' in value) {
        return rgbaToHex(value.r, value.g, value.b, value.a);
    }
    
    if (typeof value === 'number') {
        return `${value}px`;
    }

    return value;
}

function parseTokens() {
  const tokensPath = path.resolve(process.cwd(), FIGMA_TOKENS_FILE);
  if (!fs.existsSync(tokensPath)) {
    console.warn(`Token file not found at ${tokensPath}`);
    // Create an empty tokens file to prevent import errors
    const emptyContent = "// This file is auto-generated by scripts/sync-tokens.mjs\n// Do not edit this file directly.\nexport default {};\n";
    fs.writeFileSync(path.resolve(process.cwd(), OUTPUT_FILE), emptyContent);
    return;
  }

  const tokensData = JSON.parse(fs.readFileSync(tokensPath, 'utf-8'));
  const allVarsMap = new Map();
  tokensData.collections.forEach(collection => {
      collection.variables.forEach(variable => {
          allVarsMap.set(variable.id, { variable, modes: collection.modes });
      });
  });

  const tailwindTheme = {
    colors: {},
    spacing: {},
    fontSize: {},
    fontWeight: {},
    lineHeight: {},
    borderRadius: {},
  };

  allVarsMap.forEach(({ variable, modes }) => {
    const nameParts = variable.name.split('/');
    // Use the first mode of the variable's own collection
    const modeId = modes[0].modeId; 
    const rawValue = variable.valuesByMode[modeId];

    const value = processValue(rawValue, allVarsMap);
    if (value === null || value === undefined) return;
      
    // Special handling for different token types based on name
    const primaryType = nameParts[0].toLowerCase();
    const joinedKey = nameParts.slice(1).join('-');

    if (variable.resolvedType === 'COLOR') {
        let currentLevel = tailwindTheme.colors;
        for (let i = 0; i < nameParts.length - 1; i++) {
            const part = nameParts[i];
            currentLevel[part] = currentLevel[part] || {};
            currentLevel = currentLevel[part];
        }
        currentLevel[nameParts[nameParts.length - 1]] = value;
    } else if (primaryType.includes('spacing') || primaryType.includes('size')) {
        tailwindTheme.spacing[joinedKey] = value;
    } else if (primaryType.includes('font')) {
        const category = nameParts[nameParts.length - 1].toLowerCase();
        const key = nameParts.slice(1, -1).join('-');
        
        if (category === 'font-size') {
            tailwindTheme.fontSize[key] = value;
        } else if (category === 'font-weight') {
            tailwindTheme.fontWeight[key] = value.replace('px', '');
        } else if (category === 'line-height') {
            tailwindTheme.lineHeight[key] = value;
        }
    } else if (primaryType.includes('radius')) {
      tailwindTheme.borderRadius[joinedKey] = value;
    }
  });
  
  // Cleanup empty categories
  Object.keys(tailwindTheme).forEach(key => {
    if (Object.keys(tailwindTheme[key]).length === 0) {
      delete tailwindTheme[key];
    }
  });

  const outputContent = `// This file is auto-generated by scripts/sync-tokens.mjs
// Do not edit this file directly.
export default ${JSON.stringify(tailwindTheme, null, 2)};
`;
  
  const outputPath = path.resolve(process.cwd(), OUTPUT_FILE);
  fs.writeFileSync(outputPath, outputContent);
  console.log(`âœ… Tailwind tokens synced to ${OUTPUT_FILE}`);
}

parseTokens();