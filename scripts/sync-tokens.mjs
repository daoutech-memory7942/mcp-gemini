import fs from 'fs';
import path from 'path';

const FIGMA_TOKENS_FILE = 'figma-design-token.json';
const OUTPUT_FILE = 'src/tailwind-variables.css';

// Helper to convert RGBA object to a hex or rgba string
function rgbaToCss(r, g, b, a) {
  if (a !== 1) {
    return `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`;
  }
  const toHex = (c) => `0${Math.round(c * 255).toString(16)}`.slice(-2);
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

// Recursively processes a variable's value, resolving aliases
function processValue(value, allVarsMap) {
    if (!value) return null;

    if (value.type === 'VARIABLE_ALIAS') {
        const aliasData = allVarsMap.get(value.id);
        if (aliasData) {
            const { variable: aliasVar, modes: aliasModes } = aliasData;
            const modeId = aliasModes[0].modeId; // Default to first mode
            return processValue(aliasVar.valuesByMode[modeId], allVarsMap);
        }
        return null;
    }

    if (typeof value === 'object' && 'r' in value) {
        return rgbaToCss(value.r, value.g, value.b, value.a);
    }
    
    if (typeof value === 'number') {
        return `${value}px`;
    }

    return value;
}

function parseTokensToCss() {
  const tokensPath = path.resolve(process.cwd(), FIGMA_TOKENS_FILE);
  if (!fs.existsSync(tokensPath)) {
    console.warn(`Token file not found at ${tokensPath}`);
    return;
  }

  const tokensData = JSON.parse(fs.readFileSync(tokensPath, 'utf-8'));
  
  // Create a map of all variables for easy alias resolution
  const allVarsMap = new Map();
  tokensData.collections.forEach(collection => {
      collection.variables.forEach(variable => {
          allVarsMap.set(variable.id, { variable, modes: collection.modes });
      });
  });

  const cssVariables = [];

  allVarsMap.forEach(({ variable, modes }) => {
    const nameParts = variable.name.split('/');
    const modeId = modes[0].modeId;
    const rawValue = variable.valuesByMode[modeId];
    const value = processValue(rawValue, allVarsMap);

    if (value === null || value === undefined) return;

    const primaryType = nameParts[0].toLowerCase();
    let cssVarName = '';
    let cssVarValue = value;

    // Create CSS variable names like --color-btn-bg-primary, --radius-medium, etc.
    if (variable.resolvedType === 'COLOR') {
        cssVarName = `--color-${nameParts.map(p => p.toLowerCase()).join('-')}`;
    } else if (primaryType.includes('radius')) {
        cssVarName = `--radius-${nameParts.slice(1).join('-')}`;
    } else if (primaryType.includes('spacing') || primaryType.includes('size')) {
        cssVarName = `--spacing-${nameParts.slice(1).join('-')}`;
    } else {
        // Fallback for other types
        cssVarName = `--${nameParts.map(p => p.toLowerCase()).join('-')}`;
    }

    if (cssVarName) {
        cssVariables.push(`  ${cssVarName}: ${cssVarValue};`);
    }
  });

  const outputContent = `/* This file is auto-generated by scripts/sync-tokens.mjs */
/* Do not edit this file directly. */

@layer base {
  :root {
${cssVariables.join('\n')}
  }
}
`;

  const outputPath = path.resolve(process.cwd(), OUTPUT_FILE);
  fs.writeFileSync(outputPath, outputContent);
  console.log(`âœ… Tailwind CSS variables synced to ${OUTPUT_FILE}`);
}

parseTokensToCss();
